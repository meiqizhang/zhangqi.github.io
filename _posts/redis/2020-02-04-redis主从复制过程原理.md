---
layout:     post
title:      redis主从复制过程原理
category:   redis
tags:       ['主从复制']
description:   在本文中，我们将详细介绍Redis主从复制的方方面面，包括：如何使用主从复制、主从复制的原理（重点是全量复制和部分复制、以及心跳机制）、实际应用中需要注意的问题（如数据不一致问题、复制超时问题、复制缓冲区溢出问题）、主从复制相关的配置（重点是repl-timeout、client-output-buffer-limit slave）等。
---


<article class="article" id="mp-editor">
<p class="ql-align-justify">在之前的文章中曾提到过，Redis高可用的方案包括持久化、主从复制（及读写分离）、哨兵和集群。其中持久化侧重解决的是Redis数据的单机备份问题（从内存到硬盘的备份）；而主从复制则侧重解决数据的多机热备。此外，主从复制还可以实现负载均衡和故障恢复。</p> 
<p class="ql-align-justify">在本文中，我们将详细介绍Redis主从复制的方方面面，包括：如何使用主从复制、主从复制的原理（重点是全量复制和部分复制、以及心跳机制）、实际应用中需要注意的问题（如数据不一致问题、复制超时问题、复制缓冲区溢出问题）、主从复制相关的配置（重点是repl-timeout、client-output-buffer-limit slave）等。</p> 
<p><strong>一、主从复制概述</strong></p> 
<p><strong>1、主从复制</strong> </p> 
<p class="ql-align-justify">主从复制是指将一台Redis服务器的数据，复制到其它的Redis服务器。前者称为主节点(master)，后者称为从节点(slave)；数据的复制是单向的，只能由主节点到从节点。</p> 
<p class="ql-align-justify">默认情况下，每台Redis服务器都是主节点，且一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。</p> 
<p><strong>2、主从复制的作用</strong> </p> 
<p class="ql-align-justify">主从复制的作用主要包括：</p> 
<ul> 
 <li class="ql-align-justify"><strong>数据冗余：</strong>主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li> 
 <li class="ql-align-justify"><strong>故障恢复：</strong>当主节点出现问题时，可以由从节点提供服务，实现快速的故障恢复，但实际上是一种服务的冗余。</li> 
 <li class="ql-align-justify"><strong>负载均衡：</strong>在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li> 
 <li class="ql-align-justify"><strong>高可用基石：</strong>除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</li> 
</ul> 
<p><strong>二、如何使用主从复制</strong></p> 
<p class="ql-align-justify">为了更直观的理解主从复制，在介绍其内部原理之前，先说明我们需要如何操作才能开启主从复制。</p> 
<p><strong>1、建立复制</strong> </p> 
<p class="ql-align-justify">需要注意，主从复制的开启，完全是在从节点发起的，不需要我们在主节点做任何事情。</p> 
<p class="ql-align-justify">从节点开启主从复制，有3种方式：</p> 
<ul> 
 <li class="ql-align-justify"><strong>配置文件</strong></li> 
 <li class="ql-align-justify">在从服务器的配置文件中加入：slaveof&lt;masterip&gt;&lt;masterport&gt;</li> 
 <li class="ql-align-justify"><strong>启动命令</strong></li> 
 <li class="ql-align-justify">redis-server启动命令后加入：slaveof&lt;masterip&gt;&lt;masterport&gt;</li> 
 <li class="ql-align-justify"><strong>客户端命令</strong></li> 
 <li class="ql-align-justify">Redis服务器启动后直接通过客户端执行命令：slaveof&lt;masterip&gt;&lt;masterport&gt;，则该Redis实例成为从节点。</li> 
</ul> 
<p class="ql-align-justify">上述3种方式是等效的，下面以客户端命令的方式为例，看一下当执行了slaveof后，Redis主节点和从节点的变化。</p> 
<p><strong>2、实例</strong> </p> 
<p class="ql-align-justify"><strong>准备工作：启动两个节点</strong></p> 
<p class="ql-align-justify">方便起见，实验所使用的主从节点是在一台机器上的不同Redis实例，其中主节点监听6379端口，从节点监听6380端口；从节点监听的端口号可以在配置文件中修改：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/2d7f7560c44d4a02b320f17310dd1df9.png" max-width="600"></p> 
<p class="ql-align-justify">启动后可以看到：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/6658709bac904443b8ea132d763406b0.png" max-width="600"></p> 
<p class="ql-align-justify">两个Redis节点启动后（分别称为6379节点和6380节点），默认都是主节点。</p> 
<p class="ql-align-justify"><strong>建立复制 </strong></p> 
<p class="ql-align-justify">此时在6380节点执行slaveof命令，使之变为从节点：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/e5d6a350c50c41a0bbb0402473172898.png" max-width="600"></p> 
<p class="ql-align-justify"><strong>观察效果 </strong></p> 
<p class="ql-align-justify">下面验证一下，在主从复制建立后，主节点的数据会复制到从节点中。</p> 
<ul> 
 <li class="ql-align-justify">首先在从节点中查询一个不存在的key：</li> 
</ul> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/18e82abdd9244d9bbb6e6310bc88869b.png" max-width="600"></p> 
<ul> 
 <li class="ql-align-justify">然后在主节点中增加这个key：</li> 
</ul> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/f3453ee517f34351ad622bc0675cbde6.png" max-width="600"></p> 
<ul> 
 <li class="ql-align-justify">此时在从节点中再次查询这个key，会发现主节点的操作已经同步至从节点：</li> 
</ul> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/88bbeb0cb4f8468cbcfa3171364d7c18.png" max-width="600"></p> 
<ul> 
 <li class="ql-align-justify">然后在主节点删除这个key：</li> 
</ul> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/89fc24e94c164d198f8bb006c54c48a1.png" max-width="600"></p> 
<ul> 
 <li class="ql-align-justify">此时从节点中再次查询这个key，会发现主节点的操作已经同步至从节点：</li> 
</ul> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/f53ae90ca4fb4589958805c79570d15e.png" max-width="600"></p> 
<p><strong>3、断开复制</strong> </p> 
<p class="ql-align-justify">通过slaveof&lt;masterip&gt;&lt;masterport&gt;命令建立主从复制关系以后，可以通过slaveof no one断开。需要注意的是，从节点断开复制后，不会删除已有的数据，只是不再接受主节点新的数据变化。</p> 
<p class="ql-align-justify">从节点执行slaveof no one后，打印日志如下所示，可以看出断开复制后，从节点又变回为主节点：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/25a124bc10e34fc9ba3cb353d64f1650.png" max-width="600"></p> 
<p class="ql-align-justify">主节点打印日志如下：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/0415b4e100204756af3d631cd11e86ed.png" max-width="600"></p> 
<p><strong>三、主从复制的实现原理</strong></p> 
<p class="ql-align-justify">上面一节中，我们介绍了如何操作可以建立主从关系。本小节将介绍主从复制的实现原理。</p> 
<p class="ql-align-justify">主从复制过程大体可以分为3个阶段：连接建立阶段（即准备阶段）、数据同步阶段、命令传播阶段。</p> 
<p><strong>1、连接建立阶段</strong> </p> 
<p class="ql-align-justify">该阶段的主要作用是在主从节点之间建立连接，为数据同步做好准备。</p> 
<p class="ql-align-justify"><strong>步骤1：保存主节点信息</strong></p> 
<p class="ql-align-justify">从节点服务器内部维护了两个字段，即masterhost和masterport字段，用于存储主节点的ip和port信息。</p> 
<p class="ql-align-justify">需要注意的是，slaveof是异步命令，从节点完成主节点ip和port的保存后，向发送slaveof命令的客户端直接返回OK，实际的复制操作在这之后才开始进行。</p> 
<p class="ql-align-justify">这个过程中，可以看到从节点打印日志如下：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/b1673335b90045a29895460bd208dd70.png" max-width="600"></p> 
<p class="ql-align-justify"><strong>步骤2：建立socket连接</strong></p> 
<p class="ql-align-justify">从节点每秒1次调用复制定时函数replicationCron()，如果发现了有主节点可以连接，便会根据主节点的ip和port，创建socket连接。如果连接成功，则：</p> 
<p class="ql-align-justify">从节点为该socket建立一个专门处理复制工作的文件事件处理器，负责后续的复制工作，如接收RDB文件、接收命令传播等。</p> 
<p class="ql-align-justify">主节点接收到从节点的socket连接后（即accept之后），为该socket创建相应的客户端状态，并将从节点看做是连接到主节点的一个客户端，后面的步骤会以从节点向主节点发送命令请求的形式来进行。</p> 
<p class="ql-align-justify">这个过程中，从节点打印日志如下：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/6b86e9dc42b64ccbb0ddc77397712159.png" max-width="600"></p> 
<p class="ql-align-justify"><strong>步骤3：发送ping命令</strong></p> 
<p class="ql-align-justify">从节点成为主节点的客户端之后，发送ping命令进行首次请求，目的是检查socket连接是否可用以及主节点当前是否能够处理请求。</p> 
<p class="ql-align-justify">从节点发送ping命令后，可能出现3种情况：</p> 
<ul> 
 <li class="ql-align-justify">返回pong：说明socket连接正常，且主节点当前可以处理请求，复制过程继续。</li> 
 <li class="ql-align-justify">超时：一定时间后从节点仍未收到主节点的回复，说明socket连接不可用，则从节点断开socket连接，并重连。</li> 
 <li class="ql-align-justify">返回pong以外的结果：如果主节点返回其它结果，如正在处理超时运行的脚本，说明主节点当前无法处理命令，则从节点断开socket连接，并重连。</li> 
</ul> 
<p class="ql-align-justify">在主节点返回pong情况下，从节点打印日志如下：</p> 
<p class="ql-align-justify"><strong>步骤4：身份验证</strong></p> 
<p class="ql-align-justify">如果从节点中设置了masterauth选项，则从节点需要向主节点进行身份验证；没有设置该选项则不需要验证。从节点进行身份验证是通过向主节点发送auth命令进行的，auth命令的参数即为配置文件中的masterauth的值。</p> 
<p class="ql-align-justify">如果主节点设置密码的状态，与从节点masterauth的状态一致（一致是指都存在，且密码相同，或者都不存在），则身份验证通过，复制过程继续；如果不一致，则从节点断开socket连接，并重连。</p> 
<p class="ql-align-justify"><strong>步骤5：发送从节点端口信息</strong></p> 
<p class="ql-align-justify">身份验证后，从节点会向主节点发送其监听的端口号（前述例子中为6380），主节点将该信息保存到该从节点对应的客户端的slave_listening_port字段中；该端口信息除了在主节点中执行info Replication时显示以外，没有其他作用。</p> 
<p><strong>2、数据同步阶段</strong> </p> 
<p class="ql-align-justify">主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。具体执行的方式是：从节点向主节点发送psync命令（Redis2.8以前是sync命令），开始同步。</p> 
<p class="ql-align-justify">数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为全量复制和部分复制，下面会有一部分专门讲解这两种复制方式以及psync命令的执行过程，这里不再详述。</p> 
<p class="ql-align-justify">需要注意的是，在数据同步阶段之前，从节点是主节点的客户端，主节点不是从节点的客户端；而到了这一阶段及以后，主从节点互为客户端。原因在于：在此之前，主节点只需要响应从节点的请求即可，不需要主动发请求，而在数据同步阶段和后面的命令传播阶段，主节点需要主动向从节点发送请求（如推送缓冲区中的写命令），才能完成复制。</p> 
<p><strong>3、命令传播阶段</strong> </p> 
<p class="ql-align-justify">数据同步阶段完成后，主从节点进入命令传播阶段。在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p> 
<p class="ql-align-justify">在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。由于心跳机制的原理涉及部分复制，因此将在介绍了部分复制的相关内容后单独介绍该心跳机制。</p> 
<p class="ql-align-justify"><strong>延迟与不一致</strong></p> 
<p class="ql-align-justify">需要注意的是，命令传播是异步的过程，即主节点发送写命令后并不会等待从节点的回复。因此实际上主从节点之间很难保持实时的一致性，延迟在所难免。数据不一致的程度，与主从节点之间的网络状况、主节点写命令的执行频率、以及主节点中的repl-disable-tcp-nodelay配置等有关。</p> 
<p class="ql-align-justify"><strong>repl-disable-tcp-nodelay no：</strong>该配置作用于命令传播阶段，控制主节点是否禁止与从节点的TCP_NODELAY。默认no，即不禁止TCP_NODELAY。当设置为yes时，TCP会对包进行合并从而减少带宽，但是发送的频率会降低，从节点数据延迟增加，一致性变差；具体发送频率与Linux内核的配置有关，默认配置为40ms。当设置为no时，TCP会立马将主节点的数据发送给从节点，带宽增加但延迟变小。</p> 
<p class="ql-align-justify">一般来说，只有当应用对Redis数据不一致的容忍度较高，且主从节点之间网络状况不好时，才会设置为yes；多数情况使用默认值no。</p> 
<p><strong>四、全量复制和部分复制</strong></p> 
<p class="ql-align-justify">接下来我们来探讨一下数据同步阶段的全量复制和部分复制。</p> 
<p class="ql-align-justify">在Redis2.8以前，从节点向主节点发送sync命令请求同步数据，此时的同步方式是全量复制；在Redis2.8及以后，从节点可以发送psync命令请求同步数据，此时根据主从节点当前状态的不同，同步方式可能是全量复制或部分复制。后文介绍以Redis2.8及以后版本为例。</p> 
<ul> 
 <li class="ql-align-justify"><strong>全量复制：</strong>用于初次复制或其它无法进行部分复制的情况，将主节点中的所有数据都发送给从节点，是一个非常重型的操作。</li> 
 <li class="ql-align-justify"><strong>部分复制：</strong>用于网络中断等情况后的复制，只将中断期间主节点执行的写命令发送给从节点，与全量复制相比更加高效。需要注意的是，如果网络中断时间过长，造成主节点没有能够完整地保存中断期间执行的写命令，则无法进行部分复制，仍使用全量复制。</li> 
</ul> 
<p><strong>1、全量复制</strong> </p> 
<p class="ql-align-justify">Redis通过psync命令进行全量复制的过程如下：</p> 
<ul> 
 <li class="ql-align-justify">从节点判断无法进行部分复制，向主节点发送全量复制的请求；或从节点发送部分复制的请求，但主节点判断无法进行全量复制。具体判断过程需要在讲述了部分复制原理后再介绍。</li> 
 <li class="ql-align-justify">主节点收到全量复制的命令后，执行bgsave，在后台生成RDB文件，并使用一个缓冲区（称为复制缓冲区）记录从现在开始执行的所有写命令。</li> 
 <li class="ql-align-justify">主节点的bgsave执行完成后，将RDB文件发送给从节点；从节点首先清除自己的旧数据，然后载入接收的RDB文件，将数据库状态更新至主节点执行bgsave时的数据库状态。</li> 
 <li class="ql-align-justify">主节点将前述复制缓冲区中的所有写命令发送给从节点，从节点执行这些写命令，将数据库状态更新至主节点的最新状态。</li> 
 <li class="ql-align-justify">如果从节点开启了AOF，则会触发bgrewriteaof的执行，从而保证AOF文件更新至主节点的最新状态。</li> 
</ul> 
<p class="ql-align-justify">下面是执行全量复制时，主从节点打印的日志，可以看出日志内容与上述步骤是完全对应的：</p> 
<ul> 
 <li class="ql-align-justify">主节点的打印日志</li> 
</ul> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/9ad1c0c9927248369976b4598b7d2fac.png" max-width="600"></p> 
<ul> 
 <li class="ql-align-justify">从节点打印日志</li> 
</ul> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/3ec459f6d9864f779a3758d01bb916a1.jpeg" max-width="600"></p> 
<p class="ql-align-justify">其中，有几点需要注意：</p> 
<ul> 
 <li class="ql-align-justify">从节点接收了来自主节点的89260个字节的数据；</li> 
 <li class="ql-align-justify">从节点在载入主节点的数据之前要先将老数据清除；</li> 
 <li class="ql-align-justify">从节点在同步完数据后，调用了bgrewriteaof。</li> 
</ul> 
<p class="ql-align-justify">通过全量复制的过程可以看出，全量复制是非常重型的操作：</p> 
<ul> 
 <li class="ql-align-justify">主节点通过bgsave命令fork子进程进行RDB持久化，该过程是非常消耗CPU、内存(页表复制)、硬盘IO的。关于bgsave的性能问题，我在《Redis高可用详解：持久化技术及方案选择》一文中已有说明。</li> 
 <li class="ql-align-justify">主节点通过网络将RDB文件发送给从节点，对主从节点的带宽都会带来很大消耗。</li> 
 <li class="ql-align-justify">从节点清空老数据、载入新RDB文件的过程是阻塞的，无法响应客户端的命令。如果从节点执行bgrewriteaof，也会带来额外的消耗。</li> 
</ul> 
<p><strong>2、部分复制</strong> </p> 
<p class="ql-align-justify">由于全量复制在主节点数据量较大时效率太低，因此Redis2.8开始提供部分复制，用于处理网络中断时的数据同步。</p> 
<p class="ql-align-justify">部分复制的实现，依赖于三个重要的概念：</p> 
<p class="ql-align-justify"><strong>复制偏移量</strong></p> 
<p class="ql-align-justify">主节点和从节点分别维护一个复制偏移量（offset），代表的是主节点向从节点传递的字节数；主节点每次向从节点传播N个字节数据时，主节点的offset增加N；从节点每次收到主节点传来的N个字节数据时，从节点的offset增加N。</p> 
<p class="ql-align-justify">offset用于判断主从节点的数据库状态是否一致：如果二者offset相同，则一致；如果offset不同，则不一致，此时可以根据两个offset找出从节点缺少的那部分数据。例如，如果主节点的offset是1000，而从节点的offset是500，那么部分复制就需要将offset为501-1000的数据传递给从节点，而offset为501-1000的数据存储的位置，就是下面要介绍的复制积压缓冲区。</p> 
<p class="ql-align-justify"><strong>复制积压缓冲区</strong></p> 
<p class="ql-align-justify">复制积压缓冲区是由主节点维护的、固定长度的、先进先出(FIFO)队列，默认大小1MB；当主节点开始有从节点时创建，其作用是备份主节点最近发送给从节点的数据。注意，无论主节点有一个还是多个从节点，都只需要一个复制积压缓冲区。</p> 
<p class="ql-align-justify">在命令传播阶段，主节点除了将写命令发送给从节点，还会发送一份给复制积压缓冲区，作为写命令的备份；除了存储写命令，复制积压缓冲区中还存储了其中的每个字节对应的复制偏移量(offset) 。由于复制积压缓冲区定长且先进先出，所以它保存的是主节点最近执行的写命令；时间较早的写命令会被挤出缓冲区。</p> 
<p class="ql-align-justify">由于该缓冲区长度固定且有限，因此可以备份的写命令也有限，当主从节点offset的差距过大超过缓冲区长度时，将无法执行部分复制，只能执行全量复制。反过来说，为了提高网络中断时部分复制执行的概率，可以根据需要增大复制积压缓冲区的大小(通过配置repl-backlog-size)来设置；例如如果网络中断的平均时间是60s，而主节点平均每秒产生的写命令(特定协议格式)所占的字节数为100KB，则复制积压缓冲区的平均需求为6MB，保险起见，可以设置为12MB，来保证绝大多数断线情况都可以使用部分复制。</p> 
<p class="ql-align-justify">从节点将offset发送给主节点后，主节点根据offset和缓冲区大小决定能否执行部分复制：</p> 
<ul> 
 <li class="ql-align-justify">如果offset偏移量之后的数据，仍然都在复制积压缓冲区里，则执行部分复制；</li> 
 <li class="ql-align-justify">如果offset偏移量之后的数据已不在复制积压缓冲区中（数据已被挤出），则执行全量复制。</li> 
</ul> 
<p class="ql-align-justify"><strong>服务器运行ID(runid)</strong></p> 
<p class="ql-align-justify">每个Redis节点(无论主从)，在启动时都会自动生成一个随机ID(每次启动都不一样)，由40个随机的十六进制字符组成；runid用来唯一识别一个Redis节点。 通过info server命令，可以查看节点的runid：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/1cdd8e50f0e941fb947a87c370d1d0d3.png" max-width="600"></p> 
<p class="ql-align-justify">主从节点初次复制时，主节点将自己的runid发送给从节点，从节点将这个runid保存起来；当断线重连时，从节点会将这个runid发送给主节点；主节点根据runid判断能否进行部分复制：</p> 
<ul> 
 <li class="ql-align-justify">如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使用部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；</li> 
 <li class="ql-align-justify">如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进行全量复制。</li> 
</ul> 
<p><strong>3、psync命令的执行</strong> </p> 
<p class="ql-align-justify">在了解了复制偏移量、复制积压缓冲区、节点运行id之后，本节将介绍psync命令的参数和返回值，从而说明psync命令执行过程中，主从节点是如何确定使用全量复制还是部分复制的。</p> 
<p class="ql-align-justify">psync命令的执行过程可以参见下图：</p> 
<p class="ql-align-center"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/d54bc4d744f14efe8398245e3fa1baac.jpeg" max-width="600"></p> 
<p class="ql-align-center">图片来源：《Redis设计与实现》</p> 
<p class="ql-align-justify">（1）首先，从节点根据当前状态，决定如何调用psync命令：</p> 
<ul> 
 <li class="ql-align-justify">如果从节点之前未执行过slaveof或最近执行了slaveof no one，则从节点发送命令为psync ? -1，向主节点请求全量复制；</li> 
 <li class="ql-align-justify">如果从节点之前执行了slaveof，则发送命令为psync&lt;runid&gt;&lt;offset&gt;，其中runid为上次复制的主节点的runid，offset为上次复制截止时从节点保存的复制偏移量。</li> 
</ul> 
<p class="ql-align-justify">（2）主节点根据收到的psync命令及当前服务器状态来决定执行全量复制还是部分复制：</p> 
<ul> 
 <li class="ql-align-justify">如果主节点版本低于Redis2.8，则返回-ERR回复，此时从节点重新发送sync命令执行全量复制；</li> 
 <li class="ql-align-justify">如果主节点版本够新、runid与从节点发送的runid相同，且从节点发送的offset之后的数据在复制积压缓冲区中都存在，则回复+CONTINUE，表示将进行部分复制，从节点等待主节点发送其缺少的数据即可；</li> 
 <li class="ql-align-justify">如果主节点版本够新，但runid与从节点发送的runid不同，或从节点发送的offset之后的数据已不在复制积压缓冲区中(在队列中被挤出了)，则回复+FULLRESYNC&lt;runid&gt;&lt;offset&gt;，表示要进行全量复制。其中runid表示主节点当前的runid，offset表示主节点当前的offset，从节点保存这两个值，以备使用。</li> 
</ul> 
<p><strong>4、部分复制演示</strong> </p> 
<p class="ql-align-justify">在下面的演示中，网络中断几分钟后恢复，断开连接的主从节点进行了部分复制。为了便于模拟网络中断，本例中的主从节点在局域网中的两台机器上。</p> 
<p class="ql-align-justify"><strong>网络中断</strong></p> 
<p class="ql-align-justify">网络中断一段时间后，主节点和从节点都会发现失去了与对方的连接（关于主从节点对超时的判断机制，后面会有说明）；此后，从节点便开始执行对主节点的重连，由于此时网络还没有恢复，重连失败，从节点会一直尝试重连。</p> 
<p class="ql-align-justify">主节点日志如下：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/fb9b98c00dc24a76ae43e66106a65347.png" max-width="600"></p> 
<p class="ql-align-justify">从节点日志如下：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/d83305318d6c402cbc8adf3af30cb3d6.jpeg" max-width="600"></p> 
<p class="ql-align-justify"><strong>网络恢复</strong></p> 
<p class="ql-align-justify">网络恢复后，从节点连接主节点成功，并请求进行部分复制，主节点接收请求后，二者进行部分复制以同步数据。</p> 
<p class="ql-align-justify">主节点日志如下：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/dfd85108e7684fb28734e86933729b4c.png" max-width="600"></p> 
<p class="ql-align-justify">从节点日志如下：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/d29b2e6baf38406b8795a925a1744e09.jpeg" max-width="600"></p> 
<p><strong>五、命令传播阶段心跳机制</strong></p> 
<p class="ql-align-justify">在命令传播阶段，除了发送写命令，主从节点还维持着心跳机制：PING和REPLCONF ACK。心跳机制对于主从复制的超时判断、数据安全等有作用。</p> 
<p><strong>1、主→从：PING</strong> </p> 
<p class="ql-align-justify">每隔指定的时间，主节点会向从节点发送PING命令，这个PING命令的作用，主要是为了让从节点进行超时判断。</p> 
<p class="ql-align-justify">PING发送的频率由repl-ping-slave-period参数控制，单位是秒，默认值是10s。</p> 
<p class="ql-align-justify">关于该PING命令究竟是由主节点发给从节点，还是相反，有一些争议。因为在Redis的官方文档中，对该参数的注释说明是从节点向主节点发送PING命令，如下图所示：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/3edf06d50dcc4597b451b67acbec4855.png" max-width="600"></p> 
<p class="ql-align-justify">但是根据该参数的名称(含有ping-slave)及代码实现，我认为该PING命令是主节点发给从节点的。相关代码如下：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/66f2cb66638b423b8d07c6bcbd562354.jpeg" max-width="600"></p> 
<p><strong>2、从→主：REPLCONF ACK</strong> </p> 
<p class="ql-align-justify">在命令传播阶段，从节点会向主节点发送REPLCONF ACK命令，频率是每秒1次；命令格式为：REPLCONF ACK{offset}，其中offset指从节点保存的复制偏移量。</p> 
<p class="ql-align-justify">REPLCONF ACK命令的作用包括：</p> 
<p class="ql-align-justify"><strong>实时监测主从节点网络状态</strong></p> 
<p class="ql-align-justify">该命令会被主节点用于复制超时的判断。此外，在主节点中使用info Replication，可以看到其从节点的状态中的lag值，代表的是主节点上次收到该REPLCONF ACK命令的时间间隔，在正常情况下，该值应该是0或1，如下图所示：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/29662b13f5d24a469a11d4309737a9e7.png" max-width="600"></p> 
<p class="ql-align-justify"><strong>检测命令丢失</strong></p> 
<p class="ql-align-justify">从节点发送了自身的offset，主节点会与自己的offset对比，如果从节点数据缺失（如网络丢包），主节点会推送缺失的数据（这里也会利用复制积压缓冲区）。注意，offset和复制积压缓冲区，不仅可以用于部分复制，也可以用于处理命令丢失等情形；区别在于前者是在断线重连后进行的，而后者是在主从节点没有断线的情况下进行的。</p> 
<p class="ql-align-justify"><strong>辅助保证从节点的数量和延迟</strong></p> 
<p class="ql-align-justify">Redis主节点中使用min-slaves-to-write和min-slaves-max-lag参数，来保证主节点在不安全的情况下不会执行写命令。</p> 
<p class="ql-align-justify">所谓不安全，是指从节点数量太少，或延迟过高。例如min-slaves-to-write和min-slaves-max-lag分别是3和10，含义是如果从节点数量小于3个，或所有从节点的延迟值都大于10s，则主节点拒绝执行写命令。而这里从节点延迟值的获取，就是通过主节点接收到REPLCONF ACK命令的时间来判断的，即前面所说的info Replication中的lag值。</p> 
<p><strong>六、应用中的问题</strong></p> 
<p><strong>1、读写分离及其中的问题</strong> </p> 
<p class="ql-align-justify">在主从复制基础上实现的读写分离，可以实现Redis的读负载均衡：由主节点提供写服务，由一个或多个从节点提供读服务（多个从节点既可以提高数据冗余程度，也可以最大化读负载能力）；在读负载较大的应用场景下，可以大大提高Redis服务器的并发量。</p> 
<p class="ql-align-justify">下面介绍在使用Redis读写分离时，需要注意的问题：</p> 
<p class="ql-align-justify"><strong>延迟与不一致问题</strong></p> 
<p class="ql-align-justify">前面已经讲到，由于主从复制的命令传播是异步的，延迟与数据的不一致不可避免。如果应用对数据不一致的接受程度较低，可能的优化措施包括：</p> 
<ul> 
 <li class="ql-align-justify">优化主从节点之间的网络环境（如在同机房部署）；</li> 
 <li class="ql-align-justify">监控主从节点延迟（通过offset）判断，如果从节点延迟过大，通知应用不再通过该从节点读取数据；</li> 
 <li class="ql-align-justify">使用集群同时扩展写负载和读负载等。</li> 
</ul> 
<p class="ql-align-justify">在命令传播阶段以外的其它情况下，从节点的数据不一致可能更加严重，例如连接在数据同步阶段，或从节点失去与主节点的连接时等。</p> 
<p class="ql-align-justify">从节点的slave-serve-stale-data参数便与此有关，它控制这种情况下从节点的表现：如果为yes（默认值），则从节点仍能够响应客户端的命令；如果为no，则从节点只能响应info、slaveof等少数命令。该参数的设置与应用对数据一致性的要求有关；如果对数据一致性要求很高，则应设置为no。</p> 
<p class="ql-align-justify"><strong>数据过期问题</strong></p> 
<p class="ql-align-justify">在单机版Redis中，存在两种删除策略：</p> 
<ul> 
 <li class="ql-align-justify"><strong>惰性删除：</strong>服务器不会主动删除数据，只有当客户端查询某个数据时，服务器判断该数据是否过期，如果过期则删除。</li> 
 <li class="ql-align-justify"><strong>定期删除：</strong>服务器执行定时任务删除过期数据，但是考虑到内存和CPU的折中（删除会释放内存，但是频繁的删除操作对CPU不友好），该删除的频率和执行时间都受到了限制。</li> 
</ul> 
<p class="ql-align-justify">在主从复制场景下，为了主从节点的数据一致性，从节点不会主动删除数据，而是由主节点控制从节点中过期数据的删除。由于主节点的惰性删除和定期删除策略都不能保证主节点及时对过期数据执行删除操作，因此，当客户端通过Redis从节点读取数据时，很容易读取到已经过期的数据。</p> 
<p class="ql-align-justify">Redis3.2中，从节点在读取数据时，增加了对数据是否过期的判断：如果该数据已过期，则不返回给客户端。将Redis升级到3.2可以解决数据过期问题。</p> 
<p class="ql-align-justify"><strong>故障切换问题</strong></p> 
<p class="ql-align-justify">在没有使用哨兵的读写分离场景下，应用针对读和写分别连接不同的Redis节点；当主节点或从节点出现问题而发生更改时，需要及时修改应用程序读写Redis数据的连接；连接的切换可以手动进行，或者自己写监控程序进行切换，但前者响应慢、容易出错，后者实现复杂，成本都不算低。</p> 
<p class="ql-align-justify"><strong>总结</strong></p> 
<p class="ql-align-justify">在使用读写分离之前，可以考虑其他方法增加Redis的读负载能力，如尽量优化主节点（减少慢查询、减少持久化等其他情况带来的阻塞等）提高负载能力；使用Redis集群同时提高读负载能力和写负载能力等。如果使用读写分离，可以使用哨兵，使主从节点的故障切换尽可能自动化，并减少对应用程序的侵入。</p> 
<p><strong>2、复制超时问题</strong> </p> 
<p class="ql-align-justify">主从节点复制超时是导致复制中断的最重要的原因之一，本小节单独说明超时问题，下一小节说明其它会导致复制中断的问题。</p> 
<p class="ql-align-justify"><strong>超时判断意义</strong></p> 
<p class="ql-align-justify">在复制连接建立过程中及之后，主从节点都有机制判断连接是否超时，其意义在于：</p> 
<ul> 
 <li class="ql-align-justify">如果主节点判断连接超时，其会释放相应从节点的连接，从而释放各种资源，否则无效的从节点仍会占用主节点的各种资源（输出缓冲区、带宽、连接等）；此外连接超时的判断可以让主节点更准确的知道当前有效从节点的个数，有助于保证数据安全（配合前面讲到的min-slaves-to-write等参数）。</li> 
 <li class="ql-align-justify">如果从节点判断连接超时，则可以及时重新建立连接，避免与主节点数据长期的不一致。</li> 
</ul> 
<p class="ql-align-justify"><strong>判断机制</strong></p> 
<p class="ql-align-justify">主从复制超时判断的核心，在于repl-timeout参数，该参数规定了超时时间的阈值（默认60s），对于主节点和从节点同时有效；主从节点触发超时的条件分别如下：</p> 
<p class="ql-align-justify"><strong>（1）主节点：</strong>每秒1次调用复制定时函数replicationCron()，在其中判断当前时间距离上次收到各个从节点REPLCONF ACK的时间，是否超过了repl-timeout值，如果超过了则释放相应从节点的连接。</p> 
<p class="ql-align-justify"><strong>（2）从节点：</strong>从节点对超时的判断同样是在复制定时函数中判断，基本逻辑是：</p> 
<ul> 
 <li class="ql-align-justify">如果当前处于连接建立阶段，且距离上次收到主节点的信息的时间已超过repl-timeout，则释放与主节点的连接；</li> 
 <li class="ql-align-justify">如果当前处于数据同步阶段，且收到主节点的RDB文件的时间超时，则停止数据同步，释放连接；</li> 
 <li class="ql-align-justify">如果当前处于命令传播阶段，且距离上次收到主节点的PING命令或数据的时间已超过repl-timeout值，则释放与主节点的连接。</li> 
</ul> 
<p class="ql-align-justify">主从节点判断连接超时的相关源代码如下：</p> 
<p class="ql-align-right">上下滑动可查看完整代码↓</p> 
<p>/* Replication cron function, called 1 time per second. */</p> 
<p>void replicationCron(void) {</p> 
<p>static <strong>long</strong> <strong>long</strong> replication_cron_loops = 0;</p> 
<p>/* Non blocking connection timeout? */</p> 
<p>if (server.masterhost &amp;&amp;</p> 
<p>(server.repl_state == REDIS_REPL_CONNECTING ||</p> 
<p>slaveIsInHandshakeState()) &amp;&amp;</p> 
<p>(<strong>time</strong>(NULL)-server.repl_transfer_lastio) &gt; server.repl_timeout)</p> 
<p>{</p> 
<p>redisLog(REDIS_WARNING,"Timeout connecting to the MASTER...");</p> 
<p>undoConnectWithMaster();</p> 
<p>}</p> 
<p>/* Bulk transfer I/O timeout? */</p> 
<p>if (server.masterhost &amp;&amp; server.repl_state == REDIS_REPL_TRANSFER &amp;&amp;</p> 
<p>(<strong>time</strong>(NULL)-server.repl_transfer_lastio) &gt; server.repl_timeout)</p> 
<p>{</p> 
<p>redisLog(REDIS_WARNING,"Timeout receiving bulk data from MASTER... If the problem persists try to set the 'repl-timeout' parameter in redis.conf to a larger value.");</p> 
<p>replicationAbortSyncTransfer();</p> 
<p>}</p> 
<p>/* Timed out master when we are an already connected slave? */</p> 
<p>if (server.masterhost &amp;&amp; server.repl_state == REDIS_REPL_CONNECTED &amp;&amp;</p> 
<p>(<strong>time</strong>(NULL)-server.master-&gt;lastinteraction) &gt; server.repl_timeout)</p> 
<p>{</p> 
<p>redisLog(REDIS_WARNING,"MASTER timeout: no data nor PING received...");</p> 
<p>freeClient(server.master);</p> 
<p>}</p> 
<p>//此处省略无关代码……</p> 
<p>/* Disconnect timedout slaves. */</p> 
<p>if (listLength(server.slaves)) {</p> 
<p>listIter li;</p> 
<p>listNode *ln;</p> 
<p>listRewind(server.slaves,&amp;li);</p> 
<p>while((ln = listNext(&amp;li))) {</p> 
<p>redisClient *slave = ln-&gt;value;</p> 
<p>if (slave-&gt;replstate != REDIS_REPL_ONLINE) continue;</p> 
<p>if (slave-&gt;flags &amp; REDIS_PRE_PSYNC) continue;</p> 
<p>if ((server.unixtime - slave-&gt;repl_ack_time) &gt; server.repl_timeout)</p> 
<p>{</p> 
<p>redisLog(REDIS_WARNING, "Disconnecting timedout slave: %s",</p> 
<p>replicationGetSlaveName(slave));</p> 
<p>freeClient(slave);</p> 
<p>}</p> 
<p>}</p> 
<p>}</p> 
<p>//此处省略无关代码……</p> 
<p>}</p> 
<p class="ql-align-justify"><strong>需要注意的坑</strong> </p> 
<p class="ql-align-justify">下面介绍与复制阶段连接超时有关的一些实际问题：</p> 
<p class="ql-align-justify"><strong>数据同步阶段：</strong>在主从节点进行全量复制bgsave时，主节点需要首先fork子进程将当前数据保存到RDB文件中，然后再将RDB文件通过网络传输到从节点。如果RDB文件过大，主节点在fork子进程+保存RDB文件时耗时过多，可能会导致从节点长时间收不到数据而触发超时。此时从节点会重连主节点，然后再次全量复制，再次超时，再次重连……这是个悲伤的循环。为了避免这种情况的发生，除了注意Redis单机数据量不要过大，另一方面就是适当增大repl-timeout值，具体的大小可以根据bgsave耗时来调整。</p> 
<p class="ql-align-justify"><strong>命令传播阶段：</strong>如前所述，在该阶段主节点会向从节点发送PING命令，频率由repl-ping-slave-period控制；该参数应明显小于repl-timeout值(后者至少是前者的几倍)。否则，如果两个参数相等或接近，网络抖动导致个别PING命令丢失，此时恰巧主节点也没有向从节点发送数据，那从节点很容易判断超时。</p> 
<p class="ql-align-justify"><strong>慢查询导致的阻塞：</strong>如果主节点或从节点执行了一些慢查询（如keys *或者对大数据的hgetall等），导致服务器阻塞；阻塞期间无法响应复制连接中对方节点的请求，可能导致复制超时。</p> 
<p><strong>3、复制中断问题</strong> </p> 
<p class="ql-align-justify">主从节点超时是复制中断的原因之一，除此之外，还有其它情况可能导致复制中断，其中最主要的是复制缓冲区溢出问题。</p> 
<p class="ql-align-justify"><strong>复制缓冲区溢出</strong></p> 
<p class="ql-align-justify">前面曾提到过，在全量复制阶段，主节点会将执行的写命令放到复制缓冲区中，该缓冲区存放的数据包括了以下几个时间段内主节点执行的写命令：bgsave生成RDB文件、RDB文件由主节点发往从节点、从节点清空老数据并载入RDB文件中的数据。</p> 
<p class="ql-align-justify">当主节点数据量较大，或者主从节点之间网络延迟较大时，可能导致该缓冲区的大小超过了限制，此时主节点会断开与从节点之间的连接；这种情况可能引起全量复制→复制缓冲区溢出导致连接中断→重连→全量复制→复制缓冲区溢出导致连接中断……的循环。</p> 
<p class="ql-align-justify">复制缓冲区的大小由client-output-buffer-limit slave{hard limit}{soft limit}{soft seconds}配置，默认值为client-output-buffer-limit slave 256MB 64MB 60，其含义是：如果buffer大于256MB，或者连续60s大于64MB，则主节点会断开与该从节点的连接。该参数是可以通过config set命令动态配置的（即不重启Redis也可以生效）。</p> 
<p class="ql-align-justify">当复制缓冲区溢出时，主节点打印日志如下所示：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/a68721f8d2ee4e0ca689fc6f797db0dc.png" max-width="600"></p> 
<p class="ql-align-justify">需要注意的是，复制缓冲区是客户端输出缓冲区的一种，主节点会为每一个从节点分别分配复制缓冲区；而复制积压缓冲区则是一个主节点只有一个，无论它有多少个从节点。</p> 
<p><strong>4、各场景下复制的选择及优化技巧</strong> </p> 
<p class="ql-align-justify">在介绍了Redis复制的种种细节之后，现在我们可以来总结一下，在下面常见的场景中，何时使用部分复制，以及需要注意哪些问题。</p> 
<p class="ql-align-justify"><strong>第一次建立复制</strong></p> 
<p class="ql-align-justify">此时全量复制不可避免，但仍有几点需要注意：如果主节点的数据量较大，应该尽量避开流量的高峰期，避免造成阻塞；如果有多个从节点需要建立对主节点的复制，可以考虑将几个从节点错开，避免主节点带宽占用过大。此外，如果从节点过多，也可以调整主从复制的拓扑结构，由一主多从结构变为树状结构（中间的节点既是其主节点的从节点，也是其从节点的主节点）；但使用树状结构应该谨慎——主节点的直接从节点减少，降低了主节点的负担，但是多层从节点的延迟增大，数据一致性变差，且结构复杂，维护相当困难。</p> 
<p class="ql-align-justify"><strong>主节点重启</strong></p> 
<p class="ql-align-justify">主节点重启可以分为两种情况来讨论，一种是故障导致宕机，另一种则是有计划的重启。</p> 
<p class="ql-align-justify">主节点宕机</p> 
<p class="ql-align-justify">主节点宕机重启后，Runid会发生变化，因此不能进行部分复制，只能全量复制。实际上在主节点宕机的情况下，应进行故障转移处理，将其中的一个从节点升级为主节点，其它从节点从新的主节点进行复制；且故障转移应尽量的自动化，后面文章将要介绍的哨兵便可以进行自动的故障转移。</p> 
<p class="ql-align-justify">安全重启：debug reload</p> 
<p class="ql-align-justify">在一些场景下，可能希望对主节点进行重启，例如主节点内存碎片率过高，或者希望调整一些只能在启动时调整的参数。如果使用普通的手段重启主节点，会使得runid发生变化，可能导致不必要的全量复制。</p> 
<p class="ql-align-justify">为了解决这个问题，Redis提供了debug reload的重启方式：重启后，主节点的runid和offset都不受影响，避免了全量复制。</p> 
<p class="ql-align-justify">如下图所示，debug reload重启后runid和offset都未受影响：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/d903fbac29344933aac1f56c5dd8b449.png" max-width="600"></p> 
<p class="ql-align-justify">但debug reload是一柄双刃剑：它会清空当前内存中的数据，重新从RDB文件中加载，这个过程会导致主节点的阻塞，因此也需要谨慎。</p> 
<p class="ql-align-justify"><strong>从节点重启</strong></p> 
<p class="ql-align-justify">从节点宕机重启后，其保存的主节点的runid会丢失，因此即使再次执行slaveof，也无法进行部分复制。</p> 
<p class="ql-align-justify"><strong>网络中断</strong></p> 
<p class="ql-align-justify">如果主从节点之间出现网络问题，造成短时间内网络中断，可以分为多种情况讨论：</p> 
<ul> 
 <li class="ql-align-justify">网络问题时间极为短暂，只造成了短暂的丢包，主从节点都没有判定超时（未触发repl-timeout）。此时只需要通过REPLCONF ACK来补充丢失的数据即可。</li> 
 <li class="ql-align-justify">网络问题时间很长，主从节点判断超时（触发了repl-timeout），且丢失的数据过多，超过了复制积压缓冲区所能存储的范围。此时主从节点无法进行部分复制，只能进行全量复制。为了尽可能避免这种情况发生，应该根据实际情况适当调整复制积压缓冲区的大小；此外及时发现并修复网络中断，也可以减少全量复制。</li> 
 <li class="ql-align-justify">介于前述两种情况之间，主从节点判断超时，且丢失的数据仍然都在复制积压缓冲区中。此时主从节点可以进行部分复制。</li> 
</ul> 
<p><strong>5、复制相关的配置</strong> </p> 
<p class="ql-align-justify">这一节总结一下与复制有关的配置，说明这些配置的作用、起作用的阶段，以及配置方法等；通过了解这些配置，一方面加深对Redis复制的了解，另一方面掌握这些配置的方法，可以优化Redis的使用，少走坑。</p> 
<p class="ql-align-justify">配置大致可以分为主节点相关配置、从节点相关配置以及与主从节点都有关的配置，下面分别说明。</p> 
<p class="ql-align-justify"><strong>与主从节点都有关的配置</strong></p> 
<p class="ql-align-justify">首先介绍最特殊的配置，它决定了该节点是主节点还是从节点：</p> 
<ul> 
 <li class="ql-align-justify">slaveof&lt;masterip&gt;&lt;masterport&gt;：Redis启动时起作用；作用是建立复制关系，开启了该配置的Redis服务器在启动后成为从节点。该注释默认注释掉，即Redis服务器默认都是主节点。</li> 
 <li class="ql-align-justify">repl-timeout 60：与各个阶段主从节点连接超时判断有关，见前面的介绍。</li> 
</ul> 
<p class="ql-align-justify"><strong>主节点相关配置</strong></p> 
<ul> 
 <li class="ql-align-justify"><strong>repl-diskless-sync no：</strong>作用于全量复制阶段，控制主节点是否使用diskless复制（无盘复制）。所谓diskless复制，是指在全量复制时，主节点不再先把数据写入RDB文件，而是直接写入slave的socket中，整个过程中不涉及硬盘；diskless复制在磁盘IO很慢而网速很快时更有优势。需要注意的是，截至Redis3.0，diskless复制处于实验阶段，默认是关闭的。</li> 
 <li class="ql-align-justify"><strong>repl-diskless-sync-delay 5：</strong>该配置作用于全量复制阶段，当主节点使用diskless复制时，该配置决定主节点向从节点发送之前停顿的时间，单位是秒；只有当diskless复制打开时有效，默认5s。之所以设置停顿时间，是基于以下两个考虑：a.向slave的socket的传输一旦开始，新连接的slave只能等待当前数据传输结束，才能开始新的数据传输；b.多个从节点有较大的概率在短时间内建立主从复制。</li> 
 <li class="ql-align-justify"><strong>client-output-buffer-limit slave 256MB 64MB 60：</strong>与全量复制阶段主节点的缓冲区大小有关，见前面的介绍。</li> 
 <li class="ql-align-justify"><strong>repl-disable-tcp-nodelay no：</strong>与命令传播阶段的延迟有关，见前面的介绍。</li> 
 <li class="ql-align-justify"><strong>masterauth &lt;master-password&gt;：</strong>与连接建立阶段的身份验证有关，见前面的介绍。</li> 
 <li class="ql-align-justify"><strong>repl-ping-slave-period 10：</strong>与命令传播阶段主从节点的超时判断有关，见前面的介绍。</li> 
 <li class="ql-align-justify"><strong>repl-backlog-size 1mb：</strong>复制积压缓冲区的大小，见前面的介绍。</li> 
 <li class="ql-align-justify"><strong>repl-backlog-ttl 3600：</strong>当主节点没有从节点时，复制积压缓冲区保留的时间，这样当断开的从节点重新连进来时，可以进行全量复制（默认3600s）。如果设置为0，则永远不会释放复制积压缓冲区。</li> 
 <li class="ql-align-justify"><strong>min-slaves-to-write 3与min-slaves-max-lag 10：</strong>规定了主节点的最小从节点数目及对应的最大延迟，见前面的介绍。</li> 
</ul> 
<p class="ql-align-justify"><strong>从节点相关配置</strong></p> 
<ul> 
 <li class="ql-align-justify"><strong>slave-serve-stale-data yes：</strong>与从节点数据陈旧时是否响应客户端命令有关，见前面的介绍。</li> 
 <li class="ql-align-justify"><strong>slave-read-only yes：</strong>从节点是否只读；默认是只读的。由于从节点开启写操作容易导致主从节点的数据不一致，因此该配置尽量不要修改。</li> 
 <li class="ql-align-justify"> </li> 
</ul> 
<p><strong>6、单机内存大小限制</strong> </p> 
<p>我之前在《Redis高可用详解：持久化技术及方案选择》中，讲到了fork操作对Redis单机内存大小的限制。实际上在Redis的使用中， 限制单机内存大小的因素非常多，下面总结一下在主从复制中，单机内存过大可能造成的影响：</p> 
<p class="ql-align-justify"><strong>切主：</strong>当主节点宕机时，一种常见的容灾策略是将其中一个从节点提升为主节点，并将其它从节点挂载到新的主节点上，此时这些从节点只能进行全量复制。如果Redis单机内存达到10GB，一个从节点的同步时间在几分钟的级别；如果从节点较多，恢复的速度会更慢；如果系统的读负载很高，而这段时间从节点无法提供服务，会对系统造成很大的压力。</p> 
<p class="ql-align-justify"><strong>从库扩容：</strong>如果访问量突然增大，此时希望增加从节点分担读负载，如果数据量过大，从节点同步太慢，难以及时应对访问量的暴增。</p> 
<p class="ql-align-justify"><strong>缓冲区溢出：</strong>切主和从库扩容都是从节点可以正常同步的情形（虽然慢），但是如果数据量过大，造成全量复制阶段主节点的复制缓冲区溢出，从而导致复制中断，则主从节点的数据同步会全量复制→复制缓冲区溢出导致复制中断→重连→全量复制→复制缓冲区溢出导致复制中断……的循环。</p> 
<p class="ql-align-justify"><strong>超时：</strong>如果数据量过大，全量复制阶段主节点fork+保存RDB文件耗时过大，从节点长时间接收不到数据触发超时，主从节点的数据同步同样可能陷入全量复制→超时导致复制中断→重连→全量复制→超时导致复制中断……的循环。</p> 
<p class="ql-align-justify">此外，主节点单机内存除了绝对量不能太大，其占用主机内存的比例也不应过大：最好只使用50%-65%的内存，留下30%-45%的内存用于执行bgsave命令和创建复制缓冲区等。</p> 
<p><strong>7、info Replication</strong> </p> 
<p>在Redis客户端通过info Replication可以查看与复制相关的状态， 对于了解主从节点的当前状态，以及解决出现的问题都会有帮助。</p> 
<p class="ql-align-justify">主节点：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/d73b6aab379e418a8d5395efdbc5d626.png" max-width="600"></p> 
<p class="ql-align-justify">从节点：</p> 
<p class="ql-align-justify"><img src="http://5b0988e595225.cdn.sohucs.com/images/20180906/6355119ce0c24deba2eb4f946447e19f.png" max-width="600"></p> 
<p class="ql-align-justify">对于从节点，上半部分展示的是其作为从节点的状态，从connectd_slaves开始，展示的是其作为潜在的主节点的状态。</p> 
<p class="ql-align-justify">info Replication中展示的大部分内容在文章中都已经讲述，这里不再详述。</p> 
<p><strong>七、总结</strong></p> 
<p class="ql-align-justify">下面回顾一下本文的主要内容：</p> 
<p class="ql-align-justify"><strong>主从复制的作用：</strong>宏观的了解主从复制是为了解决什么样的问题，即数据冗余、故障恢复、读负载均衡等。</p> 
<p class="ql-align-justify"><strong>主从复制的操作：</strong>即slaveof命令。</p> 
<p class="ql-align-justify"><strong>主从复制的原理：</strong>主从复制包括了连接建立阶段、数据同步阶段、命令传播阶段；其中数据同步阶段，有全量复制和部分复制两种数据同步方式；命令传播阶段，主从节点之间有PING和REPLCONF ACK命令互相进行心跳检测。</p> 
<p class="ql-align-justify"><strong>应用中的问题：</strong>包括读写分离的问题（数据不一致、数据过期、故障切换等） 、复制超时问题 、复制中断问题等，然后总结了主从复制相关的配置，其中repl-timeout、client-output-buffer-limit slave等对解决Redis主从复制中出现的问题可能会有帮助。</p> 
<p class="ql-align-justify">主从复制虽然解决或缓解了数据冗余、故障恢复、读负载均衡等问题，但其缺陷仍很明显：故障恢复无法自动化；写操作无法负载均衡；存储能力受到单机的限制；这些问题的解决，需要哨兵和集群的帮助，我将在后面的文章中介绍，欢迎关注。</p> 
<p><strong>参考文献</strong> </p> 
<ul> 
 <li class="ql-align-justify">《Redis开发与运维》</li> 
 <li class="ql-align-justify">《Redis设计与实现》</li> 
 <li class="ql-align-justify">《Redis实战》</li> 
 <li class="ql-align-justify">http://mdba.cn/2015/03/16/redis复制中断问题-慢查询/</li> 
 <li class="ql-align-justify">https://redislabs.com/blog/top-redis-headaches-for-devops-replication-buffer/</li> 
 <li class="ql-align-justify">http://mdba.cn/2015/03/17/redis主从复制（2）-replication-buffer与replication-backlog/</li> 
 <li class="ql-align-justify">https://github.com/antirez/redis/issues/918</li> 
 <li class="ql-align-justify">https://blog.csdn.net/qbw2010/article/details/50496982</li> 
 <li class="ql-align-justify">Redis内存为什么不宜过大</li> 
</ul> 
<p>作者：编程迷思</p> 
<p>来源：www.cnblogs.com/kismetv/p/9236731.html</p> 
<p>dbaplus社群欢迎广大技术人员投稿，投稿邮箱：editor@dbaplus.cn<a href="https://www.sohu.com/?strategyid=00001&amp;spm=smpc.content.content.2.1580799083591oGiZ51j" target="_blank" title="点击进入搜狐首页" id="backsohucom" style="white-space: nowrap;" data-spm-data="2"><span class="backword"><i class="backsohu"></i>返回搜狐，查看更多</span></a></p>      <!-- 政务账号添加来源标示处理 -->
</article>
