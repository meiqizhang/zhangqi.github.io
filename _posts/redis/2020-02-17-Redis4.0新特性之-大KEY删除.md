---
layout:     post
title:      Redis4.0新特性之-大KEY删除
category:   redis
tags:       ['数据类型']
description: 在Redis中，对于大KEY的删除一直是个比较头疼的问题，为了不影响服务，我们通常需要自己实现工具来删除大KEY，或者在业务低峰期进行删除操作。 为了解决以上问题， Redis 4.0 新添加了 UNLINK 命令用于执行大KEY异步删除。那么这个异步删除的背后的逻辑是什么？
---

<div id="cnblogs_post_body" class="blogpost-body ">
<div id="wmd-preview-section-4236" class="wmd-preview-section preview-content">
<p>接上一篇，我们得知了redis中存在大KEY，那么这个大KEY如何删除呢？本文将从源码角度分析Redis4.0带来的新特性。</p>
<p>在Redis中，对于大KEY的删除一直是个比较头疼的问题，为了不影响服务，我们通常需要自己实现工具来删除大KEY，或者在业务低峰期进行删除操作。&nbsp;<br>为了解决以上问题， Redis 4.0 新添加了 UNLINK 命令用于执行大KEY异步删除。那么这个异步删除的背后的逻辑是什么？</p>
<p>通过源码我们可以的得知以下信息：&nbsp;<br>当我们调用异步删除UNLINK命令时：</p>
<ol>
<li>释放掉Expire Dicti 对 K-V 的引用</li>
<li>释放Main Dict 对 K-V 的引用，同时记录下这个K-V 的 Entry地址</li>
<li>计算释放掉这个V 所需要的代价，计算方法如下：&nbsp;<br>3.1 如果这个V 是一个 String 类型，则代价为 1&nbsp;<br>3.2 如果这个V 是一个复合类型，则代价为 该复合类型的长度，比如，list 则为 llen 的结果，hash 则为 hlen 的结果 …</li>
<li>根据得到的代价值，和代价阈值比对，如果小于 64 则，可以直接释放掉K-V 内存空间；如果大于 64 则，把该V 放入lazyfree 队列中，同时启动一个BIO后台JOB进行删除&nbsp;<br>4.1 在后台线程对 V 进行删除时，也是根据不同类型的 V 做不同的操作&nbsp;<br>4.2 如果是 LIST 类型，则根据LIST 长度，则直接释放空间。&nbsp;<br>4.3 如果是 SET 类型，并且数据结构采用 HASH 表存储，那么遍历整个hash表，逐个释放 k，v空间；如果数据结构采用 intset，则直接释放空间即可&nbsp;<br>4.4 如果是 ZSET 类型，并且数据结构采用 SKIPLIST 存储，由于 SKIPLIST 底层采用 HASH + skiplist 存储，那么会先释放掉 SKIPLIST 中 hash 存储空间，再释放掉 SKIPLIST 中 skiplist 部分； 如果数据结构采用 ZIPLIST 存储，则直接释放空间。&nbsp;<br>4.5 如果是 HASH 类型，并且数据结构采用 HASH表存储，则遍历整个hash表，逐个释放 k，v空间；如果数据结构采用 ZIPLIST 存储，则直接释放空间。</li>
<li>设置 V 值等于NULL</li>
<li>释放掉 K-V 空间</li>


</ol>
<p>异步删除代码如下 :</p>


</div>
<div id="wmd-preview-section-5205" class="wmd-preview-section preview-content">
<pre class="prettyprint hljs-dark"><code class="hljs xl php">int dbAsyncDelete(redisDb *db, robj *key) {<br>    <span class="hljs-comment"><span class="hljs-comment">/*  */</span><br>    <span class="hljs-function"><span class="hljs-title"><span class="hljs-keyword">if</span> (dictSize(db-&gt;<span class="hljs-function"><span class="hljs-title">expires) &gt; <span class="hljs-number">0</span>) dictDelete(db-&gt;<span class="hljs-function"><span class="hljs-title">expires,key-&gt;ptr);<br>    <span class="hljs-comment"><span class="hljs-comment">/* 在Main Dict 链表去掉引用，得到K-V entryDict */</span><br>    <span class="hljs-function"><span class="hljs-title">dictEntry *de = dictUnlink(db-&gt;<span class="hljs-function"><span class="hljs-title">dict,key-&gt;ptr);<br>    <span class="hljs-keyword"><span class="hljs-keyword">if</span> (de) {<br>        robj *val = dictGetVal(de);<br>        size_t free_effort = lazyfreeGetFreeEffort(val);<br>        <span class="hljs-comment"><span class="hljs-comment">/* 计算DEL key 的代价，根据代价决定是否采用异步删除方式 */</span><br>        <span class="hljs-keyword"><span class="hljs-keyword">if</span> (free_effort &gt; LAZYFREE_THRESHOLD) {<br>            atomicIncr(lazyfree_objects,<span class="hljs-number"><span class="hljs-number">1</span>,lazyfree_objects_mutex);<br>            bioCreateBackgroundJob(BIO_LAZY_FREE,val,<span class="hljs-keyword">NULL</span>,<span class="hljs-keyword">NULL</span>);<br>            <span class="hljs-function"><span class="hljs-title">dictSetVal(db-&gt;dict,de,<span class="hljs-keyword">NULL</span>);<br>        }<br>    }<br>    <span class="hljs-comment"><span class="hljs-comment">/* 释放K-V空间，或者采用了异步删除方式，只需要释放Key空间 */</span><br>    <span class="hljs-keyword"><span class="hljs-keyword">if</span> (de) {<br>        <span class="hljs-function"><span class="hljs-title">dictFreeUnlinkedEntry(db-&gt;dict,de);<br>        <span class="hljs-keyword"><span class="hljs-keyword">if</span> (server.cluster_enabled) slotToKeyDel(key);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number"><span class="hljs-number">1</span>;<br>    } <span class="hljs-keyword"><span class="hljs-keyword">else</span> {<br>        <span class="hljs-keyword">return</span> <span class="hljs-number"><span class="hljs-number">0</span>;<br>    }<br>}<br><br><span class="hljs-comment"><span class="hljs-comment">/* 释放LIST 空间 */</span><br>void quicklistRelease(quicklist *quicklist) {<br>    unsigned long len;<br>    quicklistNode *current, *next;<br><br>    <span class="hljs-function"><span class="hljs-title">current = quicklist-&gt;head;<br>    <span class="hljs-function"><span class="hljs-title">len = quicklist-&gt;len;<br>    <span class="hljs-keyword"><span class="hljs-keyword">while</span> (len--) {<br>        <span class="hljs-function"><span class="hljs-title">next = current-&gt;next;<br><br>        <span class="hljs-function"><span class="hljs-title">zfree(current-&gt;zl);<br>        <span class="hljs-function"><span class="hljs-title">quicklist-&gt;<span class="hljs-function"><span class="hljs-title">count -= current-&gt;count;<br>        zfree(current);<br>        <span class="hljs-function"><span class="hljs-title">quicklist-&gt;len--;<br>        current = next;<br>    }<br>    zfree(quicklist);<br>}<br><br><span class="hljs-comment"><span class="hljs-comment">/* 释放HASH表空间 */</span><br><span class="hljs-keyword">static</span> int _dictClear(dict *ht) {<br>    unsigned long i;<br>    <span class="hljs-function"><span class="hljs-title"><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; ht-&gt;<span class="hljs-function"><span class="hljs-title">size &amp;&amp; ht-&gt;used &gt; <span class="hljs-number"><span class="hljs-number">0</span>; i++) {<br>        dictEntry *he, *nextHe;<br>        <span class="hljs-function"><span class="hljs-title"><span class="hljs-keyword">if</span> ((he = ht-&gt;table[i]) == <span class="hljs-keyword">NULL</span>) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword"><span class="hljs-keyword">while</span>(he) {<br>            <span class="hljs-function"><span class="hljs-title">nextHe = he-&gt;next;<br>            dictFreeEntryKey(ht, he);<br>            dictFreeEntryVal(ht, he);<br>            free(he);<br>            <span class="hljs-function"><span class="hljs-title">ht-&gt;used--;<br>            he = nextHe;<br>        }<br>    }<br>    <span class="hljs-function"><span class="hljs-title">free(ht-&gt;table);<br>    _dictReset(ht);<br>    <span class="hljs-keyword">return</span> DICT_OK; <span class="hljs-comment"><span class="hljs-comment">/* never fails */</span><br>}<br></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></code></pre>
<p>由于异步删除实际上是先在MAIN DICT 里边把 这个K,V 的引用关系去掉了，所以当我们再次查询这个Key 的时候是查不到的，然后在慢慢释放Value 所占用的内存空间。</p>
<p>我们发现在异步进行删除的时候，不管是删除 HASH也好，还是QUICKLIST 也罢，这部分其实并没有进行一个速度的控制，只是起了一个线程让他去删除，能跑多快就跑多快，这样可能会导致我们在进行删除的时候CPU飙高。</p>
<p>这个删除大KEY是在Master 上进行的，如果这个节点有Slave呢？slave 会进行怎样的操作？同样根据代码可以发现，我们在执行UNLINK操作时，实际上在 AOF 和 通知Slave的时候只是发送了一条DEL xxkey 命令，当slave 收到del命令时，会采取以上同样的判断对这个key进行删除。</p>
</div>
<div id="wmd-preview-section-5068" class="wmd-preview-section preview-content">
<pre class="prettyprint hljs-dark"><code class="hljs xl erlang-repl"><span class="hljs-function"><span class="hljs-title">notifyKeyspaceEvent(NOTIFY_GENERIC,<span class="hljs-string">"del"</span>,c-&gt;<span class="hljs-function"><span class="hljs-title">argv[j],c-&gt;<span class="hljs-function"><span class="hljs-title">db-&gt;id);</span></span></span></span></span></span></code></pre>
</div>
</div>