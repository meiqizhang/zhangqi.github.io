---
layout:     post
title:      LSM树（Log Structured Merge Tree)
category:   data_struct
tags:       ['树']
description: 传统关系型数据库使用btree或一些变体作为存储结构，能高效进行查找。但缺点是逻辑上相离很近但物理却可能相隔很远，这就造成大量的磁盘随机读写。磁盘的随机读写比顺序读写慢很多，为了提升IO性能，需要一种能将随机操作变为顺序操作的机制，于是便有了LSM树。LSM树可以进行顺序写磁盘，从而大幅提升写操作，作为代价的是牺牲了一些读性能
---

<p>讲LSM树之前，需要提下三种基本的存储引擎，这样才能清楚<b>LSM树的由来</b>：</p>

- <p>哈希存储引擎  是哈希表的持久化实现，支持增、删、改以及随机读取操作，但不支持顺序扫描，对应的存储系统为key-value存储系统。对于key-value的插入以及查询，哈希表的复杂度都是O(1)，明显比树的操作O(n)快,如果不需要有序的遍历数据，哈希表就是your Mr.Right</p>
- <p>B树存储引擎是B树（关于B树的由来，数据结构以及应用场景可以看之前一篇博文）的持久化实现，不仅支持单条记录的增、删、读、改操作，还支持顺序扫描（B+树的叶子节点之间的指针），对应的存储系统就是关系数据库（Mysql等）。</p>
- <p>LSM树（Log-Structured Merge Tree）存储引擎和B树存储引擎一样，同样支持增、删、读、改、顺序扫描操作。而且通过批量存储技术规避磁盘随机写入问题。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。</p>

<p>LSM树（Log Structured Merge Tree，结构化合并树）的思想非常朴素，就是将<b>对数据的修改增量保持在内存中，达到指定的大小限制后将这些修改操作批量写入磁盘（由此提升了写性能），</b>是一种基于硬盘的数据结构，与B-tree相比，能显著地减少硬盘磁盘臂的开销。当然凡事有利有弊，LSM树和B+树相比，LSM树牺牲了部分读性能，用来大幅提高写性能。</p>

<p>读取时需要<b>合并磁盘中的历史数据和内存中最近的修改操作,读取时可能需要先看是否命中内存，否则需要访问较多的磁盘文件（存储在磁盘中的是许多小批量数据，由此降低了部分读性能。但是磁盘中会定期做merge操作，合并成一棵大树，以优化读性能）。</b>LSM树的优势在于有效地规避了磁盘随机写入问题，但读取时可能需要访问较多的磁盘文件。</p>

<p>代表数据库：nessDB、leveldb、hbase等</p>

<p>核心思想的核心就是<b>放弃部分读能力，换取写入的最大化能力</b>，放弃磁盘读性能来<b>换取写的顺序性</b>。极端的说，基于LSM树实现的HBase的写性能比Mysql高了一个数量级，读性能低了一个数量级。</p>

## LSM操作
<p>LSM树 <b>插入数据</b> 可以看作是一个N阶合并树。数据写操作（包括插入、修改、删除也是写）都在内存中进行，</p>

### 插入
<p>数据首先会<b>插入内存中的树。当内存树的数据量超过设定阈值后，会进行合并操作。</b>合并操作会从左至右便利内存中树的子节点 与 磁盘中树的子节点并进行合并，会用最新更新的数据覆盖旧的数据（或者记录为不同版本）。当被合并合并数据量达到磁盘的存储页大小时。会将合并后的数据持久化到磁盘，同时更新父节点对子节点的指针。</p>

### 读取
<p>LSM树 <b>读数据</b> 磁盘中书的非子节点数据也被缓存到内存中。在需要进行读操作时，总是从内存中的排序树开始搜索，如果没有找到，就从磁盘上的排序树顺序查找。</p>

### 更新
<p>在LSM树上进行一次数据<b>更新不需要磁盘访问，在内存即可完成</b>，速度远快于B+树。当数据访问以写操作为主，而读操作则集中在最近写入的数据上时，使用LSM树可以极大程度地减少磁盘的访问次数，加快访问速度。</p>

### 删除
<p>LSM树 <b>删除数据 前面讲了</b>。LSM树所有操作都是在内存中进行的，那么删除并不是物理删除。而是一个逻辑删除，会在被删除的数据上打上一个标签，当内存中的数据达到阈值的时候，会与内存中的其他数据一起顺序写入磁盘。 这种操作会占用一定空间，但是LSM-Tree 提供了一些机制回收这些空间。</p>

